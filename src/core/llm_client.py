# src/core/llm_client.py
import os

class NSEV_LLM_Client:
    """
    Implements Phase 1: Semantic Lifting and Phase 8: Refinement Prompting.
    Structures prompts to bridge the gap between AI intuition and SMT rigor.
    """

    def __init__(self, model_name="gpt-4o"):
        """
        Initializes the client with the specified model.
        """
        self.model_name = model_name
        # API keys should be managed via environment variables for security
        self.api_key = os.getenv("OPENAI_API_KEY")

    def generate_initial_prompt(self, original_code, mutant_code):
        """
        Constructs a systematic prompt based on the NSEV Prompt Architecture.
        Uses Chain-of-Thought (CoT) to force step-by-step reasoning.
        """
        prompt = f"""
### 1. ROLE ASSIGNMENT
You are a senior Verification Engineer expert in SMT-Lib 2.0 and Hoare Logic.

### 2. INPUT SPECIFICATIONS
Original Snippet (P_orig):
\"\"\"
{original_code}
\"\"\"

Mutant Snippet (P_mut):
\"\"\"
{mutant_code}
\"\"\"

### 3. REASONING CONSTRAINTS (Chain-of-Thought)
Analyze the code step-by-step to avoid hallucinations:
- VARIABLE IDENTIFICATION: List all input variables and map them to Z3 sorts (Int, Real, or BitVec). Use BitVec for bitwise operations.
- PRE-CONDITION EXTRACTION: Identify conditions (e.g., n > 0) to prune the search space.
- LOGICAL DECONSTRUCTION: Break down the logic into mathematical transformations.
- INVARIANT GENERATION: For any loops, propose a sound inductive loop invariant.

### 4. FINAL OUTPUT
Produce a complete Python-Z3 bridge script that proves forall variables: P_orig == P_mut.
The output must include:
- Symbolic variable initialization.
- Assertion of extracted pre-conditions.
- The logic for both versions and the final equivalence check (solver.add(orig != mut)).
- A command to check the solver (print(solver.check())).

Only provide the Python code block.
"""
        return prompt

    def query_model(self, prompt):
        """
        Sends the prompt to the LLM.
        In a production environment, this integrates with OpenAI or local LLM APIs.
        """
        print(f"--- Querying {self.model_name} for Semantic Lifting ---")
        
        # This is a placeholder for the actual API call logic.
        # Example: response = client.chat.completions.create(model=self.model_name, messages=[...])
        
        return "# [Z3 Python code generated by LLM based on CoT reasoning]"

    def generate_refinement_prompt(self, original_prompt, feedback_log):
        """
        Phase 8: Self-Correction Loop.
        Updates the prompt with Z3 solver feedback (syntax errors or counter-examples).
        """
        refinement_prompt = f"""
{original_prompt}

### 5. PHASE 8: SELF-CORRECTION FEEDBACK
The previous Z3 script failed during verification with the following issue:
\"\"\"
{feedback_log}
\"\"\"

Please revise the code. If it was a syntax error, fix it. 
If a counter-example was found, use CEGAR logic to strengthen the loop invariants.
"""
        return refinement_prompt

    def ensemble_consensus(self, original_code, mutant_code):
        """
        Optional: Multi-Model Ensemble Mechanism (Phase 1.2).
        Queries multiple models and uses a consensus algorithm to select the best invariant.
        """
        # Logic to aggregate responses from GPT-4o, Llama-3, etc.
        pass
 
    def generate_nested_loop_prompt(self, loop_metadata, source_code):
    """
    پیاده‌سازی استراتژی فاز ۳: انتزاع سلسله‌مراتبی برای حلقه‌های تو در تو.
    این متد از متادیتای استخراج شده توسط analyzer.py استفاده می‌کند.
    """
    # شناسایی عمق حلقه‌ها برای اعمال استراتژی پایین به بالا [cite: 134]
    num_loops = len(loop_metadata)
    
    prompt = f"""
### PHASE 3: HIERARCHICAL ABSTRACTION
The analyzer has detected {num_loops} levels of nested loops in the following code:
\"\"\"
{source_code}
\"\"\"

### TASK: BOTTOM-UP SUMMARIZATION [cite: 135]
Since nested loops cause state-space explosion, follow this modular strategy:
1. INNER-MOST LOOP (L_in): Analyze the inner-most loop and abstract its behavior into a closed-form mathematical expression (Summary S_in)[cite: 138].
2. DEPENDENCY CHECK: If the inner loop bounds depend on the outer loop variable (e.g., range(i)), generate a 'Dependent Summary Function' S_in(i)[cite: 150, 151].
3. OUTER-LOOP LIFTING: Replace the inner loop in the symbolic tree with your S_in expression.
4. INDUCTION: Prove equivalence for the outer loop using this abstracted summary.

### OUTPUT FORMAT
Provide the Z3 logic where the inner loop is modeled as a verified mathematical summary or an Uninterpreted Function[cite: 144, 180].
"""
    return prompt
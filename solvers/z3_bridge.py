# src/solvers/z3_bridge.py
from z3 import *
import sys
import io

class Z3Bridge:
    """
    Implements Phase 6: The Formal Bridge and VC Generation.
    Executes LLM-generated symbolic logic and interprets Z3 solver results.
    """

    def __init__(self):
        self.last_model = None

    def verify(self, generated_code):
        """
        Executes the generated Z3 script and returns the formal verdict.
        
        Args:
            generated_code (str): Python-Z3 code produced by the LLM.
            
        Returns:
            tuple: (verdict, model_or_error)
        """
        # A dictionary to act as a local scope for executed code
        local_scope = {}
        
        try:
            # We execute the code generated by Phase 1-5 logic
            # The LLM is expected to define a 'solver' object and run 'solver.check()'
            exec(generated_code, {"z3": sys.modules['z3']}, local_scope)
            
            if 'solver' not in local_scope:
                raise ValueError("The generated script did not initialize a 'solver' object.")
            
            solver = local_scope['solver']
            result = solver.check()

            if result == unsat:
                # Phase 6.1: UNSAT confirms mathematical equivalence
                return "unsat", None
            
            elif result == sat:
                # Phase 6.2: SAT provides a concrete counter-example
                self.last_model = solver.model()
                return "sat", self.last_model
            
            else:
                return "unknown", None

        except Exception as e:
            # Phase 8.1: Capturing syntax/runtime errors for the Refinement Loop
            raise RuntimeError(f"Formal Bridge Execution Error: {str(e)}")

    def get_counter_example_values(self):
        """Returns the specific inputs that distinguish the mutant."""
        if self.last_model:
            return {str(d): self.last_model[d] for d in self.last_model.decls()}
        return None
